library(devtools)
library(roxygen2)
library(ProSGPV)
x <- spine[,-ncol(spine)]
y <- spine[,ncol(spine)]
set.seed(1)
sgpv.2s.l <- pro.sgpv(x,y,family="binomial")
sgpv.2s.l
load_all()
x <- spine[,-ncol(spine)]
y <- spine[,ncol(spine)]
set.seed(1)
sgpv.2s.l <- pro.sgpv(x,y,family="binomial")
sgpv.2s.l
document()
check()
x <- t.housing[, -ncol(t.housing)]
y <- t.housing$V9
out.sgpv.1 <- pro.sgpv(x = x, y = y, stage = 1)
plot(out.sgpv.1)
out.sgpv.2 <- pro.sgpv(x = x, y = y)
plot(out.sgpv.2)
plot(out.sgpv.2, lambda.max = 0.01)
plot(out.sgpv.2, lpv = 1, lambda.max = 0.01)
x=out.sgpv.2
# get information from data
p <- ncol(x$x)
x.names <- colnames(x$x)
# standardize data
xs <- scale(x$x)
ys <- scale(x$y)
lambda.max <- max(abs(sapply(1:ncol(xs), function(z) xs[, z] %*% ys)) / nrow(xs)) * 1.1
step <- lambda.max / 100
# get a sequence of lambda
lambda.seq <- seq(0, lambda.max, step)
# fit lasso once
lasso <- glmnet(xs, ys)
# get coefficient estimates at each lambda
if(p < length(x$y)){
results <- sapply(lambda.seq, function(z) get.coef(xs = xs, ys = ys, lambda = z, lasso = lasso))
# prepare data to plot
to.plot <- data.frame(
lambda = rep(lambda.seq, each = p),
v = rep(x.names, length(lambda.seq)),
pe = c(results[1:p, ]),
lb = c(results[(p + 1):(2 * p), ]),
ub = c(results[(2 * p + 1):(3 * p), ])
)
}else{
results <- sapply(lambda.seq[-1], function(z) get.coef(xs = xs, ys = ys, lambda = z, lasso = lasso))
# prepare data to plot
to.plot <- data.frame(
lambda = rep(lambda.seq[-1], each = p),
v = rep(x.names, length(lambda.seq)-1),
pe = c(results[1:p, ]),
lb = c(results[(p + 1):(2 * p), ]),
ub = c(results[(2 * p + 1):(3 * p), ])
)
}
if (lpv == 1) {
to.plot$bound <- ifelse(abs(to.plot$lb) < abs(to.plot$ub), to.plot$lb, to.plot$ub)
plot.d <- to.plot[, c("lambda", "v", "bound")]
# find the location of x.names
location.beta <- to.plot$bound[to.plot$lambda == to.plot$lambda[1]]
} else if (lpv == 3) {
plot.d <- to.plot
# find the location of x.names
location.beta <- to.plot$pe[to.plot$lambda == to.plot$lambda[1]]
}
lpv=1
if (lpv == 1) {
to.plot$bound <- ifelse(abs(to.plot$lb) < abs(to.plot$ub), to.plot$lb, to.plot$ub)
plot.d <- to.plot[, c("lambda", "v", "bound")]
# find the location of x.names
location.beta <- to.plot$bound[to.plot$lambda == to.plot$lambda[1]]
} else if (lpv == 3) {
plot.d <- to.plot
# find the location of x.names
location.beta <- to.plot$pe[to.plot$lambda == to.plot$lambda[1]]
}
# get the indices of selected variables
selected.index <- x$var.index
black.index <- setdiff(1:p, selected.index)
# change the color of the variables
color.use <- c(
rep("black", length(black.index)),
rep("blue", length(selected.index))
)
location.beta <- location.beta[c(black.index, selected.index)]
var.axis <- x.names[c(black.index, selected.index)]
# find the limit of the canvas
if (lpv == 3) {
ylim <- c(
min(c(location.beta, to.plot$lb, to.plot$ub)) * 1.01,
max(c(location.beta, to.plot$lb, to.plot$ub)) * 1.01
)
ylim <- c(-max(abs(ylim)), max(abs(ylim)))
ytick <- c(
-round(max(abs(ylim)), 2), -round(max(abs(ylim)), 2) / 2, 0,
round(max(abs(ylim)), 2) / 2, round(max(abs(ylim)), 2)
)
} else if (lpv == 1) {
ylim <- c(
min(plot.d$bound) * 1.01,
max(plot.d$bound) * 1.01
)
ylim <- c(-max(abs(ylim)), max(abs(ylim)))
ytick <- c(
-round(max(abs(ylim)), 2), -round(max(abs(ylim)), 2) / 2, 0,
round(max(abs(ylim)), 2) / 2, round(max(abs(ylim)), 2)
)
}
ylim
# create a data set for the null bound
n.bound <- results[(3 * p + 1), ]
# find the lambda.1se
vlambda <- x$lambda
# plot the results
if (lpv == 1) {
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$bound, plot.d$v)
plot(lambda.seq,
type = "n", ylim = ylim, xlim = c(0, lambda.max),
xlab = expression(lambda), ylab = "Bound that is closer to the null",
main = "Solution to the two-stage algorithm with one line per variable",
axes = F, frame.plot = T
)
axis(1, at = round(seq(0, lambda.max, length.out = 5), 3))
axis(2, at = ytick, labels = c(ytick[1:2], 0, ytick[4:5]))
mtext(var.axis, side = 2, at = location.beta, col = color.use)
mtext(bquote(lambda["1se"]), side = 1, at = vlambda)
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
invisible(mapply(lines, xvals, yvals, col = 1:p))
abline(h = 0)
abline(v = vlambda, lty = 2)
} else if (lpv == 3) {
plot(lambda.seq,
type = "n", ylim = ylim, xlim = c(0, lambda.max),
xlab = expression(lambda), ylab = "Point estimates and confidence intervals",
main = "Solution to the two-stage algorithm with three lines per variable",
axes = F, frame.plot = T
)
axis(1, at = round(seq(0, lambda.max, length.out = 5), 3))
axis(2, at = ytick, labels = c(ytick[1:2], 0, ytick[4:5]))
# null region
if(p<length(x$y)){
polygon(c(lambda.seq, rev(lambda.seq)), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
}else{
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
}
# text on axis
mtext(var.axis, side = 2, at = location.beta, col = color.use)
mtext(bquote(lambda["1se"]), side = 1, at = vlambda)
# point estimates
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$pe, plot.d$v)
invisible(mapply(lines, xvals, yvals, col = 1:p))
# upper bound
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$ub, plot.d$v)
invisible(mapply(lines, xvals, yvals, col = 1:p, lty = 2))
# lower bound
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$lb, plot.d$v)
invisible(mapply(lines, xvals, yvals, col = 1:p, lty = 2))
abline(h = 0)
abline(v = vlambda, lty = 2)
}
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$bound, plot.d$v)
plot(lambda.seq,
type = "n", ylim = ylim, xlim = c(0, lambda.max),
xlab = expression(lambda), ylab = "Bound that is closer to the null",
main = "Solution to the two-stage algorithm with one line per variable",
axes = F, frame.plot = T
)
axis(1, at = round(seq(0, lambda.max, length.out = 5), 3))
axis(2, at = ytick, labels = c(ytick[1:2], 0, ytick[4:5]))
mtext(var.axis, side = 2, at = location.beta, col = color.use)
mtext(bquote(lambda["1se"]), side = 1, at = vlambda)
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
n.bound
lambda.seq[-1]
rev(lambda.seq[-1])
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
n.bound
rev(n.bound)
invisible(mapply(lines, xvals, yvals, col = 1:p))
abline(h = 0)
abline(v = vlambda, lty = 2)
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)),
col = "grey", border = "grey")
lambda.seq
# null region
if(p<length(x$y)){
polygon(c(lambda.seq, rev(lambda.seq)), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
}else{
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
}
load_all()
document()
check()
install()
