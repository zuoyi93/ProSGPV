library(devtools)
library(roxygen2)
library(ProSGPV)
x <- spine[,-ncol(spine)]
y <- spine[,ncol(spine)]
set.seed(1)
sgpv.2s.l <- pro.sgpv(x,y,family="binomial")
sgpv.2s.l
load_all()
x <- spine[,-ncol(spine)]
y <- spine[,ncol(spine)]
set.seed(1)
sgpv.2s.l <- pro.sgpv(x,y,family="binomial")
sgpv.2s.l
document()
check()
x <- t.housing[, -ncol(t.housing)]
y <- t.housing$V9
out.sgpv.1 <- pro.sgpv(x = x, y = y, stage = 1)
plot(out.sgpv.1)
out.sgpv.2 <- pro.sgpv(x = x, y = y)
plot(out.sgpv.2)
plot(out.sgpv.2, lambda.max = 0.01)
plot(out.sgpv.2, lpv = 1, lambda.max = 0.01)
x=out.sgpv.2
# get information from data
p <- ncol(x$x)
x.names <- colnames(x$x)
# standardize data
xs <- scale(x$x)
ys <- scale(x$y)
lambda.max <- max(abs(sapply(1:ncol(xs), function(z) xs[, z] %*% ys)) / nrow(xs)) * 1.1
step <- lambda.max / 100
# get a sequence of lambda
lambda.seq <- seq(0, lambda.max, step)
# fit lasso once
lasso <- glmnet(xs, ys)
# get coefficient estimates at each lambda
if(p < length(x$y)){
results <- sapply(lambda.seq, function(z) get.coef(xs = xs, ys = ys, lambda = z, lasso = lasso))
# prepare data to plot
to.plot <- data.frame(
lambda = rep(lambda.seq, each = p),
v = rep(x.names, length(lambda.seq)),
pe = c(results[1:p, ]),
lb = c(results[(p + 1):(2 * p), ]),
ub = c(results[(2 * p + 1):(3 * p), ])
)
}else{
results <- sapply(lambda.seq[-1], function(z) get.coef(xs = xs, ys = ys, lambda = z, lasso = lasso))
# prepare data to plot
to.plot <- data.frame(
lambda = rep(lambda.seq[-1], each = p),
v = rep(x.names, length(lambda.seq)-1),
pe = c(results[1:p, ]),
lb = c(results[(p + 1):(2 * p), ]),
ub = c(results[(2 * p + 1):(3 * p), ])
)
}
if (lpv == 1) {
to.plot$bound <- ifelse(abs(to.plot$lb) < abs(to.plot$ub), to.plot$lb, to.plot$ub)
plot.d <- to.plot[, c("lambda", "v", "bound")]
# find the location of x.names
location.beta <- to.plot$bound[to.plot$lambda == to.plot$lambda[1]]
} else if (lpv == 3) {
plot.d <- to.plot
# find the location of x.names
location.beta <- to.plot$pe[to.plot$lambda == to.plot$lambda[1]]
}
lpv=1
if (lpv == 1) {
to.plot$bound <- ifelse(abs(to.plot$lb) < abs(to.plot$ub), to.plot$lb, to.plot$ub)
plot.d <- to.plot[, c("lambda", "v", "bound")]
# find the location of x.names
location.beta <- to.plot$bound[to.plot$lambda == to.plot$lambda[1]]
} else if (lpv == 3) {
plot.d <- to.plot
# find the location of x.names
location.beta <- to.plot$pe[to.plot$lambda == to.plot$lambda[1]]
}
# get the indices of selected variables
selected.index <- x$var.index
black.index <- setdiff(1:p, selected.index)
# change the color of the variables
color.use <- c(
rep("black", length(black.index)),
rep("blue", length(selected.index))
)
location.beta <- location.beta[c(black.index, selected.index)]
var.axis <- x.names[c(black.index, selected.index)]
# find the limit of the canvas
if (lpv == 3) {
ylim <- c(
min(c(location.beta, to.plot$lb, to.plot$ub)) * 1.01,
max(c(location.beta, to.plot$lb, to.plot$ub)) * 1.01
)
ylim <- c(-max(abs(ylim)), max(abs(ylim)))
ytick <- c(
-round(max(abs(ylim)), 2), -round(max(abs(ylim)), 2) / 2, 0,
round(max(abs(ylim)), 2) / 2, round(max(abs(ylim)), 2)
)
} else if (lpv == 1) {
ylim <- c(
min(plot.d$bound) * 1.01,
max(plot.d$bound) * 1.01
)
ylim <- c(-max(abs(ylim)), max(abs(ylim)))
ytick <- c(
-round(max(abs(ylim)), 2), -round(max(abs(ylim)), 2) / 2, 0,
round(max(abs(ylim)), 2) / 2, round(max(abs(ylim)), 2)
)
}
ylim
# create a data set for the null bound
n.bound <- results[(3 * p + 1), ]
# find the lambda.1se
vlambda <- x$lambda
# plot the results
if (lpv == 1) {
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$bound, plot.d$v)
plot(lambda.seq,
type = "n", ylim = ylim, xlim = c(0, lambda.max),
xlab = expression(lambda), ylab = "Bound that is closer to the null",
main = "Solution to the two-stage algorithm with one line per variable",
axes = F, frame.plot = T
)
axis(1, at = round(seq(0, lambda.max, length.out = 5), 3))
axis(2, at = ytick, labels = c(ytick[1:2], 0, ytick[4:5]))
mtext(var.axis, side = 2, at = location.beta, col = color.use)
mtext(bquote(lambda["1se"]), side = 1, at = vlambda)
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
invisible(mapply(lines, xvals, yvals, col = 1:p))
abline(h = 0)
abline(v = vlambda, lty = 2)
} else if (lpv == 3) {
plot(lambda.seq,
type = "n", ylim = ylim, xlim = c(0, lambda.max),
xlab = expression(lambda), ylab = "Point estimates and confidence intervals",
main = "Solution to the two-stage algorithm with three lines per variable",
axes = F, frame.plot = T
)
axis(1, at = round(seq(0, lambda.max, length.out = 5), 3))
axis(2, at = ytick, labels = c(ytick[1:2], 0, ytick[4:5]))
# null region
if(p<length(x$y)){
polygon(c(lambda.seq, rev(lambda.seq)), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
}else{
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
}
# text on axis
mtext(var.axis, side = 2, at = location.beta, col = color.use)
mtext(bquote(lambda["1se"]), side = 1, at = vlambda)
# point estimates
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$pe, plot.d$v)
invisible(mapply(lines, xvals, yvals, col = 1:p))
# upper bound
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$ub, plot.d$v)
invisible(mapply(lines, xvals, yvals, col = 1:p, lty = 2))
# lower bound
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$lb, plot.d$v)
invisible(mapply(lines, xvals, yvals, col = 1:p, lty = 2))
abline(h = 0)
abline(v = vlambda, lty = 2)
}
xvals <- split(plot.d$lambda, plot.d$v)
yvals <- split(plot.d$bound, plot.d$v)
plot(lambda.seq,
type = "n", ylim = ylim, xlim = c(0, lambda.max),
xlab = expression(lambda), ylab = "Bound that is closer to the null",
main = "Solution to the two-stage algorithm with one line per variable",
axes = F, frame.plot = T
)
axis(1, at = round(seq(0, lambda.max, length.out = 5), 3))
axis(2, at = ytick, labels = c(ytick[1:2], 0, ytick[4:5]))
mtext(var.axis, side = 2, at = location.beta, col = color.use)
mtext(bquote(lambda["1se"]), side = 1, at = vlambda)
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
n.bound
lambda.seq[-1]
rev(lambda.seq[-1])
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
n.bound
rev(n.bound)
invisible(mapply(lines, xvals, yvals, col = 1:p))
abline(h = 0)
abline(v = vlambda, lty = 2)
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)),
col = "grey", border = "grey")
lambda.seq
# null region
if(p<length(x$y)){
polygon(c(lambda.seq, rev(lambda.seq)), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
}else{
polygon(c(lambda.seq[-1], rev(lambda.seq[-1])), c(-n.bound, rev(n.bound)), col = "grey", border = "grey")
}
load_all()
document()
check()
install()
library(devtools)
library(roxygen2)
library(ProSGPV)
set.seed(1)
data.log <- gen.sim.data(n=80,p=100,s=4,beta.min=0.5,beta.max=1.5,family="poisson")
x <- data.log[[1]]
y <- data.log[[2]]
(true.index <- data.log[[3]])
(true.beta <- data.log[[4]])
sgpv.2s.p <- pro.sgpv(x,y,family="poisson")
sgpv.2s.p
coef(sgpv.2s.p)
head(predict(sgpv.2s.p))
set.seed(1)
data.log <- gen.sim.data(n=10,p=100,s=4,beta.min=0.5,beta.max=1.5,family="poisson")
x.new <- data.log[[1]]
y.new <- data.log[[2]]
head(predict(sgpv.2s.p,newx=x.new))
cbind(y.new,predict(sgpv.2s.p,newx=x.new))
data.frame(Observed=y.new,Predicted=predict(sgpv.2s.p,newx=x.new))
plot(sgpv.2s.p)
plot(sgpv.2s.p,lambda.max = 0.7)
plot(sgpv.2s.p,lambda.max = 0.6)
png("vignettes/assets/glm.fig.2.png", units = "in", width = 9, height = 6, res = 300)
plot(sgpv.2s.p,lambda.max = 0.6)
dev.off()
png("vignettes/assets/glm.fig.3.png", units = "in", width = 9, height = 6, res = 300)
plot(sgpv.2s.p,lambda.max = 0.6,lpv=1)
dev.off()
data.cox <- gen.sim.data(n=100, p=20, s=8, family="cox",
beta.min=0.5, beta.max=1.5, sig=2)
seet.seed(1)
data.cox <- gen.sim.data(n=100, p=20, s=8, family="cox",
beta.min=0.5, beta.max=1.5, sig=2)
x <- data.cox[[2]]
set.seed(1)
data.cox <- gen.sim.data(n=100, p=20, s=8, family="cox",
beta.min=0.5, beta.max=1.5, sig=2)
x <- data.cox[[2]]
y <- data.cox[[2]]
true.index <- data.cox[[3]]
true.beta <- data.cox[[4]]
true.index <- data.cox[[3]]
true.beta <- data.cox[[4]]
true.index
sgpv.1s.c <- pro.sgpv(x,y,stage=1,family="cox")
sgpv.1s.c
set.seed(1)
data.cox <- gen.sim.data(n=100, p=20, s=4, family="cox",
beta.min=0.5, beta.max=1.5, sig=2)
x <- data.cox[[2]]
y <- data.cox[[2]]
(true.index <- data.cox[[3]])
true.beta <- data.cox[[4]]
sgpv.1s.c <- pro.sgpv(x,y,stage=1,family="cox")
sgpv.1s.c
data.cox <- gen.sim.data(n=100, p=20, s=4, family="cox",
beta.min=0.5, beta.max=1.5, sig=1)
x <- data.cox[[2]]
y <- data.cox[[2]]
(true.index <- data.cox[[3]])
true.beta <- data.cox[[4]]
sgpv.1s.c <- pro.sgpv(x,y,stage=1,family="cox")
sgpv.1s.c
set.seed(1)
data.cox <- gen.sim.data(n=100, p=20, s=4, family="cox",
beta.min=0.5, beta.max=1.5, sig=2)
x <- data.cox[[2]]
y <- data.cox[[2]]
(true.index <- data.cox[[3]])
true.beta <- data.cox[[4]]
sgpv.1s.c <- pro.sgpv(x,y,stage=1,family="cox")
sgpv.1s.c
sgpv.1s.c$var.index
sgpv.1s.c$var.label
sgpv.1s.c$x
set.seed(1)
data.cox <- gen.sim.data(n=100, p=20, s=4, family="cox",
beta.min=0.5, beta.max=1.5, sig=2)
x <- data.cox[[1]]
y <- data.cox[[2]]
(true.index <- data.cox[[3]])
true.beta <- data.cox[[4]]
sgpv.1s.c <- pro.sgpv(x,y,stage=1,family="cox")
sgpv.1s.c$var.index
sgpv.1s.c
sgpv.2s.c <- pro.sgpv(x,y,stage=2,family="cox")
sgpv.2s.c
set.seed(1)
data.cox <- gen.sim.data(n=100, p=20, s=4, family="cox",
beta.min=0.5, beta.max=1.5, sig=2)
x <- data.cox[[1]]
y <- data.cox[[2]]
(true.index <- data.cox[[3]])
true.beta <- data.cox[[4]]
sgpv.1s.c <- pro.sgpv(x,y,stage=1,family="cox")
sgpv.1s.c
sgpv.2s.c
coef(sgpv.1s.c)
summary(sgpv.1s.c)
predict(sgpv.1s.c)
summary(sgpv.2s.c)
plot(sgpv.1s.c)
png("vignettes/assets/glm.fig.4.png", units = "in", width = 4, height = 10, res = 300)
plot(sgpv.1s.c)
dev.off()
png("vignettes/assets/glm.fig.4.png", units = "in", width = 6, height = 10, res = 300)
plot(sgpv.1s.c)
dev.off()
data.cox <- gen.sim.data(n=100, p=40, s=4, family="cox",
beta.min=2.5, beta.max=3.5, sig=2)
x <- data.cox[[1]]
y <- data.cox[[2]]
(true.index <- data.cox[[3]])
true.beta <- data.cox[[4]]
sgpv.2s.c <- pro.sgpv(x,y,stage=2,family="cox")
sgpv.2s.c
data.cox <- gen.sim.data(n=100, p=40, s=0, family="cox",
beta.min=2.5, beta.max=3.5, sig=2)
x <- data.cox[[1]]
y <- data.cox[[2]]
(true.index <- data.cox[[3]])
true.beta <- data.cox[[4]]
sgpv.2s.c <- pro.sgpv(x,y,stage=2,family="cox")
sgpv.2s.c <- pro.sgpv(x,y,stage=1,family="cox")
sgpv.2s.c
sgpv.2s.c <- pro.sgpv(x,y,stage=2,family="cox")
if (is.null(colnames(x))) colnames(x) <- paste("V", 1:ncol(x), sep = "")
# standardize inputs in linear regression
if (family == "gaussian") {
xs <- scale(x)
ys <- scale(y)
} else {
xs <- as.matrix(x)
ys <- y
}
family="cox"
# standardize inputs in linear regression
if (family == "gaussian") {
xs <- scale(x)
ys <- scale(y)
} else {
xs <- as.matrix(x)
ys <- y
}
lasso.cv <- cv.glmnet(xs, Surv(ys[, 1], ys[, 2]), family = "cox")
load_all()
data.cox <- gen.sim.data(n=100, p=40, s=0, family="cox",
beta.min=2.5, beta.max=3.5, sig=2)
x <- data.cox[[1]]
y <- data.cox[[2]]
(true.index <- data.cox[[3]])
true.beta <- data.cox[[4]]
sgpv.2s.c <- pro.sgpv(x,y,stage=2,family="cox")
lasso.cv <- cv.glmnet(xs, Surv(ys[, 1], ys[, 2]), family = "cox")
lambda <- lasso.cv$lambda.1se
candidate.index <- which(as.numeric(coef(lasso.cv, s = lambda)) != 0)
candidate.index
load_all()
sgpv.2s.c <- pro.sgpv(x,y,stage=2,family="cox")
sgpv.2s.c
plot(sgpv.2s.c)
sgpv.1s.c <- pro.sgpv(x,y,stage=1,family="cox")
plot(sgpv.1s.c)
load_all()
plot(sgpv.2s.c)
load_all()
document()
check()
check()
document()
check()
install()
document()
check()
install()
release()
spell_check()
spell_check()
release()
build()
styler::dir()
library(devtools)
styler::dir()
styler::style_dir()
document()
check()
install()
build()
library("devtools")
library(ProSGPV)
library(roxygen2)
set.seed(30)
data.linear <- gen.sim.data(n=100, p=200, s=4)
# explanatory variables
x <- data.linear[[1]]
# outcome
y <- data.linear[[2]]
# true support
(true.index <- data.linear[[3]])
# true coefficients
true.beta <- data.linear[[4]]
set.seed(1)
h.sgpv <- pro.sgpv(x,y)
h.sgpv
plot(h.sgpv)
library(devtools)
library(roxygen2)
styler::style_dir()
document()
check()
install()
build()
library(devtools)
library(roxygen2)
document()
load_all()
gen.hold.out <- function(n = 90, p = 1000, k = 4, n_folds = 10) {
# create the design matrix
set.seed(1)
X <- matrix(rnorm(n = n * p), nrow = n)
# sample Y from a logistic model
strength <- 1 # signal strength
beta <- strength * c(rep(1, k), rep(0, p - k))
# determine bayes error with this beta vector
set.seed(555)
n_holdout <- 10000
X_holdout <- matrix(rnorm(n_holdout * p), nrow = n_holdout)
p_holdout <- 1 / (1 + exp(-X_holdout %*% beta))
Y_holdout <- (runif(n_holdout) < p_holdout) * 1.0
return(list(X_holdout, Y_holdout))
}
temp <- gen.hold.out()
X_holdout <- temp[[1]]
Y_holdout <- temp[[2]]
# --------------------------------------------------------
# step 2: calculate mean error and  true error in one run
# --------------------------------------------------------
# returns the prediction error in the test set
get.error.fold <- function(x.train, y.train, x.test, y.test) {
sgpv <- pro.sgpv(x.train, y.train, family = "binomial")
(predict(sgpv, newx = x.test) > 0.5) != y.test
}
# one time
f.one.time <- function(X_holdout, Y_holdout, n = 90, n_folds = 10) {
# get training and validation data
train_idx <- sample(1:nrow(X_holdout), n, replace = F)
test_idx <- setdiff(1:nrow(X_holdout), train_idx)
x <- X_holdout[train_idx, ]
y <- Y_holdout[train_idx]
# create fold ID
fold.index <- cut(seq(1, n), breaks = n_folds, labels = FALSE)
# prediction error in one run
temp.cv <- sapply(1:n_folds, function(i) {
get.error.fold(
x.train = x[which(fold.index != i), ],
y.train = y[which(fold.index != i)],
x.test = x[which(fold.index == i), ],
y.test = y[which(fold.index == i)]
)
})
out.1 <- mean(temp.cv)
out.3 <- sd(temp.cv)/sqrt(n)
# true error"
sgpv.test <- pro.sgpv(X_holdout[train_idx,],Y_holdout[train_idx],
family="binomial")
pred.test <- predict(sgpv.test,newx=X_holdout[test_idx,])>0.5
out.2 <- mean(pred.test != Y_holdout[test_idx])
return(c(out.1, out.2, out.3))
}
f.one.time(X_holdout, Y_holdout)
