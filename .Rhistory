load_all()
plot(out.sgpv.2,lpv=1)
load_all()
plot(out.sgpv.2,lpv=1,lambda.max=0.2)
plot(out.sgpv.2,lpv=1,lambda.max=0.1)
plot(out.sgpv.2,lpv=1,lambda.max=0.025)
document()
check()
suppressMessages(mapply(lines,xvals,yvals,col=1:p))
suppressWarnings(mapply(lines,xvals,yvals,col=1:p))
mapply(lines,xvals,yvals,col=1:p,SIMPLIFY = FALSE)
mapply(lines,xvals,yvals,col=1:p,SIMPLIFY = T)
mapply(lines,xvals,yvals,col=1:p,SIMPLIFY = FALSE)
mapply(lines,xvals,yvals,col=1:p,SIMPLIFY = T)
lapply(lines,xvals,yvals,col=1:p)
mapply(lines,xvals,yvals,col=1:p)
invisible(mapply(lines,xvals,yvals,col=1:p))
document()
check()
# find the location of x.names
location.beta <- to.plot$pe[to.plot$lambda==0]
location.beta
selected.index
selected.index=obj$var.index
# change the color of the variables
color.use <- rep("black",p)
color.use[selected.index] <- "blue"
color.use
lpv=3
# find the limit of the canvas
if(lpv==3){
ylim <- c(min(c(location.beta,to.plot$lb,to.plot$ub) )*1.1,
max(c(location.beta,to.plot$lb,to.plot$ub))*1.1)
ylim <- c(-max(abs(ylim)),max(abs(ylim)))
ytick <- c(-round(max(abs(ylim)),2),-round(max(abs(ylim)),2)/2,0,
round(max(abs(ylim)),2)/2,round(max(abs(ylim)),2) )
}else if (lpv==1){
ylim <- c(min(plot.d$bound) * 1.1,
max(plot.d$bound) * 1.1)
ylim <- c(-max(abs(ylim)),max(abs(ylim)))
ytick <- c(-round(max(abs(ylim)),2),-round(max(abs(ylim)),2)/2,0,
round(max(abs(ylim)),2)/2,round(max(abs(ylim)),2) )
}
# create a data set for the null bound
n.bound <- results[(3*p+1),]
vlambda
vlambda=obj$lambda
lambda.max
plot(lambda.seq,type="n",ylim=ylim,xlim=c(0,lambda.max),
xlab=expression(lambda),ylab="Point estimates and confidence intervals",
main="Solution to the two-stage algorithm with three lines per variable",
axes=F,frame.plot=T)
axis(1,at=round(seq(0,lambda.max,length.out=5),3) )
axis(2,at=ytick,labels=c(ytick[1:2],0,ytick[4:5]))
abline(h=0)
abline(v=vlambda,lty=2)
polygon(c(lambda.seq,rev(lambda.seq)),c(-n.bound,rev(n.bound)),col="skyblue")
mtext(x.names,side=2,at=location.beta,col=color.use)
# point estimates
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$pe,plot.d$v)
plot.d$lambda
# point estimates
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$pe,plot.d$v)
plot.d$pe
head(plot.d)
to.plot
plot.d <- to.plot
# find the location of x.names
location.beta <- to.plot$pe[to.plot$lambda==0]
yvals <- split(plot.d$pe,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p))
# upper bound
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$ub,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p,lty=2))
# lower bound
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$lb,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p,lty=2))
# find the limit of the canvas
if(lpv==3){
ylim <- c(min(c(location.beta,to.plot$lb,to.plot$ub) )*1.01,
max(c(location.beta,to.plot$lb,to.plot$ub))*1.01)
ylim <- c(-max(abs(ylim)),max(abs(ylim)))
ytick <- c(-round(max(abs(ylim)),2),-round(max(abs(ylim)),2)/2,0,
round(max(abs(ylim)),2)/2,round(max(abs(ylim)),2) )
}else if (lpv==1){
ylim <- c(min(plot.d$bound) * 1.01,
max(plot.d$bound) * 1.01)
ylim <- c(-max(abs(ylim)),max(abs(ylim)))
ytick <- c(-round(max(abs(ylim)),2),-round(max(abs(ylim)),2)/2,0,
round(max(abs(ylim)),2)/2,round(max(abs(ylim)),2) )
}
# plot the results
if(lpv==1){
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$bound,plot.d$v)
plot(lambda.seq,type="n",ylim=ylim,xlim=c(0,lambda.max),
xlab=expression(lambda),ylab="Bound that is closer to the null",
main="Solution to the two-stage algorithm with one line per variable",
axes=F,frame.plot=T)
axis(1,at=round(seq(0,lambda.max,length.out=5),3) )
axis(2,at=ytick,labels=c(ytick[1:2],0,ytick[4:5]))
abline(h=0)
abline(v=vlambda,lty=2)
polygon(c(lambda.seq,rev(lambda.seq)),c(-n.bound,rev(n.bound)),col="skyblue")
mtext(x.names,side=2,at=location.beta,col=color.use)
invisible(mapply(lines,xvals,yvals,col=1:p))
}else if (lpv==3){
plot(lambda.seq,type="n",ylim=ylim,xlim=c(0,lambda.max),
xlab=expression(lambda),ylab="Point estimates and confidence intervals",
main="Solution to the two-stage algorithm with three lines per variable",
axes=F,frame.plot=T)
axis(1,at=round(seq(0,lambda.max,length.out=5),3) )
axis(2,at=ytick,labels=c(ytick[1:2],0,ytick[4:5]))
abline(h=0)
abline(v=vlambda,lty=2)
polygon(c(lambda.seq,rev(lambda.seq)),c(-n.bound,rev(n.bound)),col="skyblue")
mtext(x.names,side=2,at=location.beta,col=color.use)
# point estimates
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$pe,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p))
# upper bound
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$ub,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p,lty=2))
# lower bound
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$lb,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p,lty=2))
}
document()
check()
mtext(bquote(lambda["1se"]),side=1,at=vlambda)
load_all()
x = t.housing[,-ncol(t.housing)]
y = t.housing$V9
out.sgpv.2 <- pro.sgpv(x = x, y = y, stage = 2)
plot(out.sgpv.2,lpv=3)
png("fig/fig.1.png", units="in", width=9, height=9, res=300)
plot(out.sgpv.2,lpv=3)
dev.off()
png("fig/fig.1.png", units="in", width=6, height=6, res=300)
plot(out.sgpv.2,lpv=3)
dev.off()
png("fig/fig.1.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=3)
dev.off()
png("fig/fig.2.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=3,lambda.max=0.01)
dev.off()
png("fig/fig.3.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=1,lambda.max=0.01)
dev.off()
load("~/Dropbox/Zuo Project/Relaxed Lasso/Paper 1 SGPV null bound/Manuscript/Tables and Figures/Data/candidate1.RData")
out.sgpv.sim <- pro.sgpv(X,Y,stage=2)
plot(out.sgpv.sim,lpv=1)
load_all()
plot(out.sgpv.sim,lpv=1)
load_all()
plot(out.sgpv.sim,lpv=1)
load_all()
png("fig/fig.4.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.sim,lpv=1)
dev.off()
.libPaths()
summary
use_r("summary")
object <- pro.sgpv(x,y,stage=1)
lm.d <- data.frame(yy=object$y,xx = object$x[,object$var.index])
colnames(lm.d)[-1] <- object$var.label
summary(lm(yy~.,data=lm.d))
load_all()
summary(object)
object
document()
document()
document()
load_all()
summary(object)
load_all()
summary(object)
check()
document()
check()
object<-pro.sgpv(x,y,stage=2)
load_all()
plot(object)
plot(object,lambda.max=0.01)
selected.index=object$var.index
# change the color of the variables
color.use <- rep("black",p)
color.use[selected.index] <- "blue"
color.use
p=ncol(object$x)
xs <- scale(object$x)
ys <- scale(object$y)
# maximum lambda
if(is.null(lambda.max)) lambda.max <- max(abs(sapply(1:ncol(xs),function(z) xs[,z] %*% ys ))/nrow(xs))*1.1
lambda.max
step = lambda.max/100
# get a sequence of lambda
lambda.seq <- seq(0,lambda.max,step)
# get coefficient estimates at each lambda
results <- sapply(lambda.seq,function(z) get.coef(xs=xs,ys=ys,lambda=z))
# prepare data to plot
to.plot <- data.frame(lambda=rep(lambda.seq,each=p),
v=rep(x.names,length(lambda.seq)),
pe=c(results[1:p,]),
lb=c(results[(p+1):(2*p),]),
ub=c(results[(2*p+1):(3*p),])
)
lpv
if(lpv==1){
to.plot$bound <- ifelse(abs(to.plot$lb)<abs(to.plot$ub), to.plot$lb, to.plot$ub )
plot.d <- to.plot[,c("lambda","v","bound")]
# find the location of x.names
location.beta <- to.plot$bound[to.plot$lambda==0]
}else if(lpv==3){
plot.d <- to.plot
# find the location of x.names
location.beta <- to.plot$pe[to.plot$lambda==0]
}
location.beta
black.index <- setdiff(1:p,selected.index)
black.index
# change the color of the variables
color.use <- c(rep("black",length(black.index)),
rep("blue",length(selected.index)))
color.use
location.beta <- location.beta[c(black.index,selected.index)]
# find the limit of the canvas
if(lpv==3){
ylim <- c(min(c(location.beta,to.plot$lb,to.plot$ub) )*1.01,
max(c(location.beta,to.plot$lb,to.plot$ub))*1.01)
ylim <- c(-max(abs(ylim)),max(abs(ylim)))
ytick <- c(-round(max(abs(ylim)),2),-round(max(abs(ylim)),2)/2,0,
round(max(abs(ylim)),2)/2,round(max(abs(ylim)),2) )
}else if (lpv==1){
ylim <- c(min(plot.d$bound) * 1.01,
max(plot.d$bound) * 1.01)
ylim <- c(-max(abs(ylim)),max(abs(ylim)))
ytick <- c(-round(max(abs(ylim)),2),-round(max(abs(ylim)),2)/2,0,
round(max(abs(ylim)),2)/2,round(max(abs(ylim)),2) )
}
# create a data set for the null bound
n.bound <- results[(3*p+1),]
# find the lambda.1se
vlambda <- x$lambda
vlambda=object$lambda
# plot the results
if(lpv==1){
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$bound,plot.d$v)
plot(lambda.seq,type="n",ylim=ylim,xlim=c(0,lambda.max),
xlab=expression(lambda),ylab="Bound that is closer to the null",
main="Solution to the two-stage algorithm with one line per variable",
axes=F,frame.plot=T)
axis(1,at=round(seq(0,lambda.max,length.out=5),3) )
axis(2,at=ytick,labels=c(ytick[1:2],0,ytick[4:5]))
mtext(x.names,side=2,at=location.beta,col=color.use)
mtext(bquote(lambda["1se"]),side=1,at=vlambda)
invisible(mapply(lines,xvals,yvals,col=1:p))
polygon(c(lambda.seq,rev(lambda.seq)),c(-n.bound,rev(n.bound)),col="grey",border="grey")
abline(h=0)
abline(v=vlambda,lty=2)
}else if (lpv==3){
plot(lambda.seq,type="n",ylim=ylim,xlim=c(0,lambda.max),
xlab=expression(lambda),ylab="Point estimates and confidence intervals",
main="Solution to the two-stage algorithm with three lines per variable",
axes=F,frame.plot=T)
axis(1,at=round(seq(0,lambda.max,length.out=5),3) )
axis(2,at=ytick,labels=c(ytick[1:2],0,ytick[4:5]))
# text on axis
mtext(x.names,side=2,at=location.beta,col=color.use)
mtext(bquote(lambda["1se"]),side=1,at=vlambda)
# point estimates
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$pe,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p))
# upper bound
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$ub,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p,lty=2))
# lower bound
xvals <- split(plot.d$lambda,plot.d$v)
yvals <- split(plot.d$lb,plot.d$v)
invisible(mapply(lines,xvals,yvals,col=1:p,lty=2))
# null region
polygon(c(lambda.seq,rev(lambda.seq)),c(-n.bound,rev(n.bound)),col="grey",border="grey")
abline(h=0)
abline(v=vlambda,lty=2)
}
load_all()
document()
check()
# prepare the data
x = t.housing[,-ncol(t.housing)]
y = t.housing$V9
out.sgpv.2 <- pro.sgpv(x = x, y = y, stage = 2)
png("man/figures/fig.1.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=3)
dev.off()
png("man/figures/fig.2.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=3,lambda.max=0.01)
dev.off()
png("man/figures/fig.3.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=1,lambda.max=0.01)
dev.off()
load("~/Dropbox/Zuo Project/Relaxed Lasso/Paper 1 SGPV null bound/Manuscript/Tables and Figures/Data/candidate1.RData")
out.sgpv.sim <- pro.sgpv(X,Y,stage=2)
png("man/figures/fig.4.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.sim,lpv=1)
dev.off()
load_all()
png("man/figures/fig.4.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.sim,lpv=1)
dev.off()
load_all()
png("man/figures/fig.4.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.sim,lpv=1)
dev.off()
png("man/figures/fig.1.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=3)
dev.off()
png("man/figures/fig.2.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=3,lambda.max=0.01)
dev.off()
png("man/figures/fig.3.png", units="in", width=7, height=7, res=300)
plot(out.sgpv.2,lpv=1,lambda.max=0.01)
dev.off()
document()
check()
library(glmnet)
library(corrr)
library(openxlsx)
# load the data
rw.d <- read.xlsx("Real data.xlsx",sheet="Data")
# load the data
rw.d <- read.xlsx("~/Dropbox/Zuo Project/Relaxed Lasso/Paper 1 SGPV null bound/Manuscript/R markdown/Real world/Real data.xlsx",sheet="Data")
# determine the variables of interest
raw.d <- data.frame(rw.d[,c(6:12,13:31,108)])
colnames(raw.d) <- gsub('[.]',"",colnames(raw.d))
dim(raw.d) # 372 by 27
head(raw.d)
library(devtools)
install_github("zuoyi93/ProSGPV")
library(ProSGPV)
# prepare the data
x = t.housing[,-ncol(t.housing)]
y = t.housing$V9
# run one-stage algorithm
out.sgpv.1 <- pro.sgpv(x = x, y = y, stage = 1)
out.sgpv.1
set.seed(100)
out.sgpv.2 <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2
# example when two-stage algorithm gives different model as the one-stage algortihm
set.seed(1)
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d # V8 V12 V13 V15 V17 V26
# example when two-stage algorithm gives different model as the one-stage algortihm
set.seed(10)
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d # V8 V12 V13 V15 V17 V26
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d # V8 V12 V13 V15 V17 V26
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d # V8 V12 V13 V15 V17 V26
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d # V8 V12 V13 V15 V17 V26
# example when two-stage algorithm gives different model as the one-stage algortihm
set.seed(55)
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d # V8 V12 V13 V15 V17 V26
pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d$var.index # V8 V12 V13 V15 V17 V26
out.sgpv.2.d$var.label # V8 V12 V13 V15 V17 V26
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d$var.label # V8 V12 V13 V15 V17 V26
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d$var.label # V8 V12 V13 V15 V17 V26
head(x)
out.sgpv.2.d$lambda # V8 V12 V13 V15 V17 V26
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d$lambda # V8 V12 V13 V15 V17 V26
out.sgpv.2.d
out.sgpv.2.d$lambda
out.sgpv.2.d <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2.d$lambda # V8 V12 V13 V15 V17 V26
out.sgpv.2.d
out.sgpv.2 <- pro.sgpv(x = x, y = y, stage = 2)
summary(out.sgpv.2) # V8 V12 V13 V15 V17 V26
out.sgpv.2 <- pro.sgpv(x = x, y = y, stage = 2)
summary(out.sgpv.2) # V8 V12 V13 V15 V17 V26
out.sgpv.2 <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2$lambda # V8 V12 V13 V15 V17 V26
out.sgpv.2 <- pro.sgpv(x = x, y = y, stage = 2)
out.sgpv.2$lambda # V8 V12 V13 V15 V17 V26
out.sgpv.2
t.housing %>% correlate() %>%
network_plot(min_cor=0.1,colours=c("red","white","blue"))
library(corrr)
t.housing %>% correlate() %>%
network_plot(min_cor=0.1,colours=c("red","white","blue"))
library(dplyr)
t.housing %>% correlate() %>%
network_plot(min_cor=0.1,colours=c("red","white","blue"))
dev.off()
png("~/Dropbox/Zuo Project/Relaxed Lasso/Paper 1 SGPV null bound/Manuscript/Tables and Figures/Figures/supp.fig.7.png",width=7,height=7,units="in",res=300)
t.housing %>% correlate() %>%
network_plot(min_cor=0.1,colours=c("red","white","blue"))
dev.off()
t.housing %>% correlate() %>%
network_plot(min_cor=0.1,colours=c("red","white","blue"),lab_col="red")
library(Hmisc)
head(x)
out.sgpv.1.v8 <- pro.sgpv(x = x[,-7], y = y, stage = 1)
out.sgpv.1.v8 # V8 V12 V13 V15 V17 V25 V26
out.sgpv.2.v8 <- pro.sgpv(x = x[,-7], y = y, stage = 2)
out.sgpv.2.v8 # V8 V12 V13 V15 V17 V26
out.sgpv.2.v8 <- pro.sgpv(x = x[,-7], y = y, stage = 2)
out.sgpv.2.v8 # V5 V6 V17
set.seed(1)
out.sgpv.2.v8 <- pro.sgpv(x = x[,-7], y = y, stage = 2)
out.sgpv.2.v8 # V5 V6 V17
set.seed(2)
out.sgpv.2.v8 <- pro.sgpv(x = x[,-7], y = y, stage = 2)
out.sgpv.2.v8 # V5
set.seed(3)
out.sgpv.2.v8 <- pro.sgpv(x = x[,-7], y = y, stage = 2)
out.sgpv.2.v8 # V5 V6 v17
getHdata(nhgh)
head(nhgh)
nhgh.d <- nhgh[,c(-1,-4,-5)]
# change sex to binary coding
nhgh.d$sex <- as.character(nhgh.d$sex)
nhgh.d$sex[nhgh.d$sex=="male"] <- "0"
nhgh.d$sex[nhgh.d$sex=="female"] <- "1"
nhgh.d$sex <- as.integer(nhgh.d$sex)
nhgh.d <- nhgh.d[complete.cases(nhgh.d),]
nhgh.d %>% correlate() %>%
network_plot(min_cor=0.1,colours=c("red","white","blue"))
png("~/Dropbox/Zuo Project/Relaxed Lasso/Paper 1 SGPV null bound/Manuscript/Tables and Figures/Figures/supp.fig.10.png",width=7,height=7,units="in",res=300)
nhgh.d %>% correlate() %>%
network_plot(min_cor=0.1,colours=c("red","white","blue"))
dev.off()
# create design matrix
X <- as.matrix(raw.d[,-ncol(raw.d)])
xs <- scale(X)
# create vector for outcome
Y <- as.vector(raw.d[,ncol(raw.d)])
ys <- scale(Y)
cv.scad <- cv.ncvreg(X, Y,penalty="SCAD")
out.scad <- as.numeric(which(coef(cv.scad,s=cv.scad$lambda.min)[-1]!=0))
cat("SCAD selects",colnames(X)[out.scad])
library(ncvreg) # scad mcp
library(plus) # mc+
cv.scad <- cv.ncvreg(X, Y,penalty="SCAD")
out.scad <- as.numeric(which(coef(cv.scad,s=cv.scad$lambda.min)[-1]!=0))
cat("SCAD selects",colnames(X)[out.scad])
mcplus <- plus(X,Y,method = "mc+")
sigma <- sqrt(summary(lm(Y~X))$sigma^2)
n <- nrow(raw.d)
lambda.mcplus <- sqrt(2/n*log(ncol(X)))*sigma
out.mcplus <- which(coef(mcplus,lam=lambda.mcplus)!=0)
cat("MC+ selects",colnames(X)[out.mcplus])
out.sgpv.2 # V8 V12 V13 V15 V17 V26
out.sgpv.2$var.index
ols.coef <- coef(lm(Y~X))[-1]
adalasso <- cv.glmnet(X,Y,keep=T,penalty.factor = 1/sqrt(abs(ols.coef)))
out.al <- which(as.numeric(coef(adalasso, s=adalasso$lambda.1se))[-1] != 0)
cat("Adaptive lasso selects",colnames(X)[out.al])
ols.coef <- coef(lm(Y~X))[-1]
adalasso <- cv.glmnet(X,Y,keep=T,penalty.factor = 1/sqrt(abs(ols.coef)))
out.al <- which(as.numeric(coef(adalasso, s=adalasso$lambda.1se))[-1] != 0)
cat("Adaptive lasso selects",colnames(X)[out.al])
library(ggplot2)
library(hrbrthemes)
# scad has variability
value.scad <- numeric(26)
value.scad[c(1:10,12,14,15,20,21,23,24,25)] <- 1
# mc+ doesn't have variability
value.mcplus <- numeric(26)
value.mcplus[c(1,6:8,13,16,20,25)] <- 1
# one-stage algortihm doesn't have variability
value.1s <- numeric(26)
value.1s[c(7,9,10,12,14,22,23)] <- 1
# two-stage is pretty stable
value.2s <- numeric(26)
value.2s[c(7, 9, 10, 12, 14, 23)] <- 1
# adaptive lasso has variability
value.al <- numeric(26)
value.al[c(6,7,11,14,17,22)] <- 1
data=data.frame(X=rep(c(paste("V",2:8,sep=""),paste("V",11:29,sep="")),5),
Y=rep(c("SCAD","MC+","AL", "One-stage","Two-stage"),each=26),
Z=c(value.scad, value.mcplus, value.al, value.1s, value.2s))
data$X <- factor(data$X,levels=c(paste("V",2:8,sep=""),paste("V",11:29,sep="")))
data$Y <- factor(data$Y,levels=rev(c("SCAD","MC+","AL","One-stage","Two-stage")))
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile() +
scale_fill_gradient(low="white", high="blue") +
theme_ipsum()+labs(x="",y="")+theme(legend.position="none")
png("~/Dropbox/Zuo Project/Relaxed Lasso/Paper 1 SGPV null bound/Manuscript/Tables and Figures/Figures//supp.fig.8.png",width=12,height=4,units="in",res=300)
ggplot(data, aes(X, Y, fill= Z)) +
geom_tile() +
scale_fill_gradient(low="white", high="blue") +
theme_ipsum()+labs(x="",y="")+theme(legend.position="none")
dev.off()
